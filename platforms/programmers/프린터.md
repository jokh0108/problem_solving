# [프린터](https://programmers.co.kr/learn/courses/30/lessons/42587)

## 문제 설명

여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다.

```
- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.
- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.
- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.
- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.
```

아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다.

![image0.png](assets/d3ae656b-bb7b-421c-9f74-fa9ea800b860.png)

이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다.

```
(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 '()'으로 표현합니다. 또한 모든 '()'는 반드시 레이저를 표현합니다.
(b) 쇠막대기의 왼쪽 끝은 여는 괄호 '('로, 오른쪽 끝은 닫힌 괄호 ')'로 표현됩니다.
```

위 예의 괄호 표현은 그림 위에 주어져 있습니다.
쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다.

쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요.

## 제한사항

- arrangement의 길이는 최대 100,000입니다.
- arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.

## 입출력 예

| arrangement            | return |
| ---------------------- | ------ |
| ()(((()())(())()))(()) | 17     |

## 입출력 예 설명

문제에 나온 예와 같습니다.

## 문제 풀이 과정

1. 스택으로 풀었다. 이 문제와 같이 **쌍을 이루는 요소**와 **이전 정보**가 필요한 경우면 스택이 아닐까 의심해보는 것이 좋은 것 같다.

2. 다음과 같이 생각하면 된다. 한 번에 전체적인 상황을 보려하는게 아니라 앞에서부터 차례대로 리스트를 훑을 것이니 어떻게 변화해 가는지를 생각하는게 좋다(원래 컴퓨터의 동작 흐름대로).

   - ![1548756542687](assets/1548756542687.png)
   - 일단 0~1번은 지나치고, 2~5번을 보자. `'('`문자가 올때마다 새로운 막대기가 추가된다. 이때마다 push해주고, 막대기 갯수를 늘리면 좋을 것 같다. 그런데, 5번 `'('`문자는 상황이 다르다. 다음에 `')'`문자가 왔기 때문에 `'('`문자는 새로운 막대기가 아닌 레이저의 시작을 의미했던 것이다. 따라서, `'('`를 만날 때마다 `'('가 새로운 막대기를 의미한다`가 아니라 현재 문자가 `'('`일 때 `이전 문자가 '('였으면 막대기를 추가한다`가 알맞다. 즉, ***현재 문자와 이전 문자를 함께 봐야한다는 말이다.***
   - 5번까지 왔으면, 막대기가 3개이다. 이 말은 (아직 자르지 않았지만) 조각도 3개라는 말과 같다. 
   - 5~6번에 이르러서 막대기를 자르는 레이저가 나왔다. 이 때마다 막대기와 조각의 갯수는 어떻게 될까?  막대기는 그대로 3개이지만 (막대기를 하나의 줄로 생각하자) 조각은 3개만큼 늘었다. 그 다음 7~8 레이저가 와도 조각은 3개가 늘어날 것이다. 즉, 현재 남아있는 막대기 줄 수 만큼 조각이 늘어나는 것이다. 
   - 그 다음 9번에 이르러서 맨 위의 막대기의 끝이 보인다. 그런데 6, 8 번도 똑같이 `')'`였으므로 pop을 하면 똑같은 쌍이 되는데 뭐가 다른걸까? 바로 이전에 왔던 문자가 무엇인가에 따라 다르다. 이전 문자가 `')'`였으면 막대기의 끝을 의미하고 `'('`였으면 레이저를 의미하는 것이다. 이런 방식으로 모든 케이스를 다루면 알고리즘 완성이다.

3.  위의 논리에 따라 입력이 두 가지 뿐이므로 이전에 온 문자와 함께 케이스를 나누면 좋을 것 같다. 일단 `'('`문자가 오면 push를 하고 `')'`문자가 오면 pop을 한다. 이 조건을 먼저 고정시키고, 이전에 오는 문자(`arrangement[i-1]`)에 따라 어떻게 변하는지를 처리해준다.

| 문자쌍 | 데이터 처리                | 의미                                                   |
| ------ | -------------------------- | ------------------------------------------------------ |
| `((`   | 막대기 + 1, 조각 + 1       | 앞 `'('`가 새로운 막대였음을 알려줌                    |
| `()`   | 조각 + (현재 막대기 줄 수) | 레이저                                                 |
| `))`   | 막대기 - 1                 | 맨위에 위맨치한 막대기의 끝임을 알려줌                 |
| `)(`   | -                          | 다음에 새 막대기가 올 것. 데이터 처리는 할 필요가 없다 |


```python
from collections import deque

def find_max_prioriy(deq):
    max_priority = 0
    for each in deq:
        if max_priority < each[1]:
            max_priority = each[1]
    return max_priority

def solution(priorities, location):
    answer = 0
    max_priority = 0
    seq = 0
    pri_and_loc = []
    for i in range(len(priorities)):
        pri_and_loc.append((i, priorities[i]))
        if max_priority < priorities[i]:
            max_priority = priorities[i]
    deq = deque(pri_and_loc)
    while deq:
        #break
        #print(deq)
        job = deq.popleft()
        if job[1] < max_priority:
            deq.append(job)
        else:
            seq += 1
            if job[0] == location:
                #print(seq)
                return seq
            else:
                max_priority = find_max_prioriy(deq)
```

- 근데 굳이 deque 필요 없이 리스트 그대로 쓰면 됨;

```python
def solution(priorities, location):
    answer = 0
    max_priority = max(priorities)
    while True:
        #break
        #print(deq)
        current = priorities.pop(0)
        if current != max_priority:
            priorities.append(current)
            if location == 0:
                location = len(priorities)-1
            else:
                location -= 1
        else:
            answer += 1
            if location == 0:
                break
            else:
                location -= 1
            max_priority = max(priorities)
    #print(answer)
    return location
```



## 팁

- 파이썬은 리스트를 바로 스택으로 활용할 수 있다. 그래서 스택 라이브러리가 따로 없다.
